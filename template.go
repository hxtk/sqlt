package sqlt

import (
	"bytes"
	"errors"
	"io/fs"
	"sync"
	"text/template"

	"github.com/jackc/pgx/v5"
)

// ErrAlreadyUsed occurs when a program calls Parse or ParseFS on a template
// after its first use.
//
// Templates lazily escape template sequences on first use, so parsing more
// templates after first use would allow an undefined state where the template
// has unescaped nodes.
var ErrAlreadyUsed = errors.New("cannot parse template after first use")

// Template wraps `template.Template` providing SQL parameter substitution to
// avoid directly constructing SQL with string interpolation.
//
// Branches get interpreted as normal, resulting in literal strings within
// the query, but variable substitutions instead bind named parameters,
// and executing the query returns a parameter map containing these named
// parameters.
type Template struct {
	text *template.Template

	escErr  error
	escaped bool
	once    sync.Once
}

// New produces a new template, analogous to `template.New`.
func New(name string) *Template {
	return &Template{
		text: template.New(name).Funcs(template.FuncMap{
			escapeFuncName: new(argFormatter).Format,
		}),
	}
}

// Execute executes the template and returns a query, a `pgx.NamedArgs`
// containing any parameter bindings generated by the template, and an error.
//
// If the error has a nil value, this method guarantees the validity of the
// other retur values.
//
// Example:
//
//	pool, err := pgxpool.New(context.TODO(), os.Getenv("DATABASE_URL"))
//	if err != nil {
//		panic(err)
//	}
//
//	tpl, err := sqlt.New("")
//	if err != nil {
//		panic(err)
//	}
//
//
//	tpl, err = tpl.Parse("SELECT * FROM table WHERE id={{ .id }}")
//	if err != nil {
//		panic(err)
//	}
//
//	query, args, err := tpl.Execute(map[string]int{"id": 3}
//	if err != nil {
//		panic(err)
//	}
//
//	rows, err := pool.Query(context.TODO(), query, args)
func (t *Template) Execute(data any) (query string, params pgx.NamedArgs, err error) {
	tpl, fmter, err := t.preExec()
	if err != nil {
		return "", nil, err
	}

	var b bytes.Buffer
	err = tpl.Execute(&b, data)
	if err != nil {
		return "", nil, err
	}

	return b.String(), fmter.Args(), err
}

// ExecuteTemplate executes a named subtemplate within this template.
//
// This method especially helps when you load templates using `ParseFS`.
// Other than the extra argument for the template name, its behavor matches
// the preceding Execute method.
func (t *Template) ExecuteTemplate(name string, data any) (query string, params pgx.NamedArgs, err error) {
	tpl, fmter, err := t.preExec()
	if err != nil {
		return "", nil, err
	}

	var b bytes.Buffer
	err = tpl.ExecuteTemplate(&b, name, data)
	if err != nil {
		return "", nil, err
	}

	return b.String(), fmter.Args(), err
}

func (t *Template) preExec() (*template.Template, *argFormatter, error) {
	err := t.escape()
	if err != nil {
		return nil, nil, err
	}

	tpl, err := t.Clone()
	if err != nil {
		return nil, nil, err
	}
	var fmter argFormatter
	tpl.Funcs(template.FuncMap{
		escapeFuncName: fmter.Format,
	})

	return tpl.text, &fmter, nil
}

func (t *Template) escape() error {
	t.once.Do(func() {
		if t.escaped {
			return
		}
		if t.text.Tree != nil {
			t.escErr = escapeNode(t.text, t.text.Root)
			if t.escErr != nil {
				return
			}
			for _, v := range t.text.Templates() {
				t.escErr = escapeNode(v, v.Root)
				if t.escErr != nil {
					return
				}
			}
		}
	})
	return t.escErr
}

// Clone creates a deep copy of the template.
func (t *Template) Clone() (*Template, error) {
	tpl, err := t.text.Clone()
	if err != nil {
		return nil, err
	}

	return &Template{
		text:    tpl,
		escErr:  t.escErr,
		escaped: t.escaped,
	}, nil
}

// Funcs passes new functions into the `Funcs` of the underlying text/template.
func (t *Template) Funcs(funcMap template.FuncMap) *Template {
	t.text.Funcs(funcMap)
	return t
}

// ParseFS loads many templates from a file system interface.
func (t *Template) ParseFS(fsys fs.FS, patterns ...string) (*Template, error) {
	if t.escaped {
		return nil, ErrAlreadyUsed
	}

	_, err := t.text.ParseFS(fsys, patterns...)
	if err != nil {
		return nil, err
	}

	return t, nil
}

// Parse loads a single template into the root of this template.
func (t *Template) Parse(templateStr string) (*Template, error) {
	if t.escaped {
		return nil, ErrAlreadyUsed
	}

	_, err := t.text.Parse(templateStr)
	if err != nil {
		return nil, err
	}

	return t, nil
}
