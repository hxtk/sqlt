package sqlt

import (
	"bytes"
	"errors"
	"io/fs"
	"maps"
	"slices"
	"sync"
	"text/template"

	"github.com/jackc/pgx/v5"
)

// ErrAlreadyUsed occurs when a program calls Parse or ParseFS on a template
// after its first use.
//
// Templates lazily escape template sequences on first use, so parsing more
// templates after first use would allow an undefined state where the template
// has unescaped nodes.
var ErrAlreadyUsed = errors.New("cannot parse template after first use")

// Template wraps `template.Template` providing SQL parameter substitution to
// avoid directly constructing SQL with string interpolation.
//
// Branches get interpreted as normal, resulting in literal strings within
// the query, but variable substitutions instead bind named parameters,
// and executing the query returns a parameter map containing these named
// parameters.
type Template struct {
	text *template.Template

	sanitizers SanitizerMap

	escErr  error
	escaped bool
	once    sync.Once
}

// New produces a new template, analogous to `template.New`.
func New(name string) *Template {
	return &Template{
		text: template.New(name).Funcs(template.FuncMap{
			escapeFuncName: new(argFormatter).Format,
		}),
		sanitizers: SanitizerMap{
			escapeFuncName: func() Sanitizer {
				return new(argFormatter)
			},
		},
	}
}

// Execute executes the template and returns a query, a `pgx.NamedArgs`
// containing any parameter bindings generated by the template, and an error.
//
// If the error has a nil value, this method guarantees the validity of the
// other retur values.
//
// Example:
//
//	pool, err := pgxpool.New(context.TODO(), os.Getenv("DATABASE_URL"))
//	if err != nil {
//		panic(err)
//	}
//
//	tpl, err := sqlt.New("")
//	if err != nil {
//		panic(err)
//	}
//
//
//	tpl, err = tpl.Parse("SELECT * FROM table WHERE id={{ .id }}")
//	if err != nil {
//		panic(err)
//	}
//
//	query, args, err := tpl.Execute(map[string]int{"id": 3}
//	if err != nil {
//		panic(err)
//	}
//
//	rows, err := pool.Query(context.TODO(), query, args)
func (t *Template) Execute(data any) (query string, params pgx.NamedArgs, err error) {
	tpl, sans, err := t.preExec()
	if err != nil {
		return "", nil, err
	}

	var b bytes.Buffer
	err = tpl.Execute(&b, data)
	if err != nil {
		return "", nil, err
	}

	return b.String(), collectArgs(sans...), err
}

// ExecuteTemplate executes a named subtemplate within this template.
//
// This method especially helps when you load templates using `ParseFS`.
// Other than the extra argument for the template name, its behavor matches
// the preceding Execute method.
func (t *Template) ExecuteTemplate(name string, data any) (query string, params pgx.NamedArgs, err error) {
	tpl, sans, err := t.preExec()
	if err != nil {
		return "", nil, err
	}

	var b bytes.Buffer
	err = tpl.ExecuteTemplate(&b, name, data)
	if err != nil {
		return "", nil, err
	}

	return b.String(), collectArgs(sans...), err
}

func (t *Template) preExec() (*template.Template, []Sanitizer, error) {
	err := t.escape()
	if err != nil {
		return nil, nil, err
	}

	tpl, err := t.Clone()
	if err != nil {
		return nil, nil, err
	}

	sanMap := make(map[string]Sanitizer, len(t.sanitizers))
	for k, v := range t.sanitizers {
		sanMap[k] = v()
	}

	funcMap := make(template.FuncMap, len(sanMap))
	for k, v := range sanMap {
		funcMap[k] = v.Format
	}
	tpl.Funcs(funcMap)

	sanitizers := make([]Sanitizer, 0, len(sanMap))
	sanitizers = slices.AppendSeq(sanitizers, maps.Values(sanMap))

	return tpl.text, sanitizers, nil
}

func (t *Template) escape() error {
	t.once.Do(func() {
		if t.escaped {
			return
		}
		if t.text.Tree != nil {
			safeNames := slices.Collect(maps.Keys(t.sanitizers))
			t.escErr = escapeNode(t.text, t.text.Root, safeNames)
			if t.escErr != nil {
				return
			}
			for _, v := range t.text.Templates() {
				t.escErr = escapeNode(v, v.Root, safeNames)
				if t.escErr != nil {
					return
				}
			}
		}
	})
	return t.escErr
}

// Clone creates a deep copy of the template.
func (t *Template) Clone() (*Template, error) {
	tpl, err := t.text.Clone()
	if err != nil {
		return nil, err
	}

	return &Template{
		text:       tpl,
		sanitizers: t.sanitizers,
		escErr:     t.escErr,
		escaped:    t.escaped,
	}, nil
}

// ParseFS loads many templates from a file system interface.
func (t *Template) ParseFS(fsys fs.FS, patterns ...string) (*Template, error) {
	if t.escaped {
		return nil, ErrAlreadyUsed
	}

	_, err := t.text.ParseFS(fsys, patterns...)
	if err != nil {
		return nil, err
	}

	return t, nil
}

// Parse loads a single template into the root of this template.
func (t *Template) Parse(templateStr string) (*Template, error) {
	if t.escaped {
		return nil, ErrAlreadyUsed
	}

	_, err := t.text.Parse(templateStr)
	if err != nil {
		return nil, err
	}

	return t, nil
}

// Funcs passes new functions into the `Funcs` of the underlying text/template.
func (t *Template) Funcs(funcMap template.FuncMap) *Template {
	t.text.Funcs(funcMap)
	return t
}

// Sanitizers extends the behavior of `Funcs` to support adding SQL sanitizing
// functions that emit safe SQL strings and generate parameter bindings.
//
// The caller has the responsibility of ensuring that the parameter bindings
// generated by each Sanitizer don't have namespace conflicts with one another.
//
// This package reserves the prefix "sqlt" for its own bindings.
func (t *Template) Sanitizers(sanitizers SanitizerMap) *Template {
	// Add the sanitizers to the current FuncMap so the template can compile.
	funcMap := make(template.FuncMap, len(sanitizers))
	for k, v := range sanitizers {
		funcMap[k] = v().Format
	}
	t.text.Funcs(funcMap)

	maps.Copy(t.sanitizers, sanitizers)
	return t
}
